%main section about the different models 



\subsection{MIP Formulations}
For many combinatorial Problems it is the best practical solution to formulate them as a Mixed Integer Problem and just 
solve this problem with modern MIP Solvers such as CPlex, Gurobi, SCIP etc. Often there are different possible 
formulations as 
MIP, which might yield very different running times due to numerical or algorithmical reasons. In our problem, it is 
easy to model the flow conservation and the ingoing and outgoing flow on vertices. Like described before, we can assign 
a negative weight to an arc variable and this way maximize flow over this arc by minimizing the overall cost. This 
would be the typical MIP formulation of a min cost flow:

\begin{align*}
  &\min \sum_{a\in A} w_a\cdot x_a  \\
  %TODO an die balance-intervall formulierung anpassen
 s.t. & \sum_{a\in \delta^+(v)}x_a - \sum_{a\in\delta^- (v)}x_a = d_v\ &\forall v\in V \\
  & c_l(a)\le x_a \le c_u(a) & \forall a\in A
\end{align*}

This model still allows cyclic flow, so we have to find constraints to avoid cyclicity. 
\subsubsection{Model 1: Node Potentials}
%TODO welche formulierungen koennte es noch geben fuer dieses problem?
%TODO PORTA results and polytope of the problem?

One idea (that is unfortunately not a linear problem formulation anymore) would be to set potentials on the nodes and 
allow only flow from higher to lower potential. This is quite close to the application of our problem in gas flow 
computation, where gas will only flow from places with high pressure to places with lower pressure in the network. So 
each vertex $v$ would get a variable $\pi_v$ for its potential, each arc $a$ as before a variable $x_a$ for the amount 
of flow. Then we add the constraint $$x_a\cdot (\pi_v -\pi_w)\ge 0\,\forall a=(v,w)\in A $$
We have to ensure that the values of the potentials are all 
different, or that there is no flow between nodes of the same potential. Otherwise any solution where all potentials 
are set to the same value would fulfill this constraint, regardless if it is acyclic or not. So in practice we could 
set a constant $\varepsilon > 0$ to describe the minimum distance between the potentials. A feasible 
solution now has to fulfill the constraint above on every arc. If we set up the constraint as above, we get the Mixed 
Integer Nonlinear Program

\begin{align*}
  &\min \sum_{a\in A} w_a\cdot x_a & \\
 s.t. & \sum_{a\in \delta^+(v)}x_a - \sum_{a\in\delta^- (v)}x_a &=& d_v\ &\forall v\in V \\
 & x_a &\le& c_u(a) & \forall a\in A\\
 & -x_a &\le& c_l(a) & \forall a\in A\\
 & -x_a\cdot (\pi_v -\pi_w)&\le& 0 &\forall a=(v,w)\in A\\
 & (\pi_v - \pi_w)^2 &\ge& \varepsilon &\forall v,w \in V\\
 & x_a \in \R & & &\forall a\in A\\
 & \pi_v \in \R & & & \forall v\in V\\
 & d_a \in \{0,1\} & & &\forall a\in A\\
\end{align*}

We show that this flow indeed is an acyclic one:

\begin{prop}
 A flow which fulfills the constraints of the above nonlinear program is always acyclic.
\end{prop}
\begin{proof}
 Assume a flow fulfilling the above constraints would have cyclic flow on a cycle $C$. Without loss of generality 
we label the vertices on the cycle from $1$ to $n$ and assume all arcs are directed forward on this cycle. This means 
there are arcs $a_1=(v_1,v_2),a_2=(v_2,v_3), \dots a_n=(v_n, v_1)\in C$ such that $x_{a_i} > 0 \,\forall i={1,\dots , 
n}$. Also we know from the constraints  $x_a\cdot (\pi_v -\pi_w)\ge 0$ and $\pi_v - \pi_w \neq 0$ (Hence $\Rightarrow 
\pi_v\neq\pi_w)\, \forall v,w\in V$. So we conclude an ordering of the vertices potentials: $x_{a_1}\cdot (\pi_{v_1} 
-\pi_{v_2})\ge 0 \Rightarrow \pi_{v_1}>\pi_{v_2}$ and so on. This yields a sequence $\pi_{v_1}>\pi_{v_2}>\dots 
>\pi_{v_n}>\pi_{v_1}$, which is a contradiction. \Lightning
\end{proof}

However, solving nonlinear mixed integer programs comes with many difficulties, so we will use indicator constraints 
or an equivalent Big-M constraint to get a mixed integer formulation avoiding these difficulties. For this we  replace 
$$x_a\cdot (\pi_w -\pi_v)\le 0 \,\forall a=(v,w)\in A $$ and $$(\pi_v - \pi_w)^2 \ge \varepsilon \,\forall v,w \in V$$

%introduce rho (=richtung) variables
Instead we introduce a new binary variable $\rho_{vw}$ to indicate flow direction on $a=(v,w)$, and say this variable 
has to be 1 if flow is from $v$ to $w$ and 0 if it is from $w$ to $v$. Also if $\rho_{vw}$ is $1$ the potential 
$\pi_v$ of $v$ has to be greater than the potential $\pi_w$ of $w$ and the other way around. So with indicator 
constraints we get
\begin{align*}
 &\rho_{vw}=1 &\Rightarrow &\pi_v\ge\pi_w +1\\
 &\rho_{vw}=0 &\Rightarrow &\pi_w\ge\pi_v +1\\
 &\rho_{vw}=1 &\Rightarrow &f((v,w))\ge 0\\
 &\rho_{vw}=0 &\Rightarrow &f((v,w))\le 0\\
 &\rho_{vw} \in \{0,1\}&&
\end{align*}
We can reformulate these indicator constraints as
\begin{align*}
 &\pi_v-\pi_w &\ge & N(\rho_{vw}-1)+1\\
 &\pi_v-\pi_w&\le &N\rho_{vw}-1 \\
 &f((v,w))&\ge& M(\rho_{vw}-1)\\
 &f((v,w))&\le & M\rho_{vw}\\
 &\rho_{vw} \in \{0,1\}&&\\
\end{align*}
where $N\in \R$ and $M\in \R$ are sufficient big constants. Sufficient big in this case could mean we choose 
$N=|V|\, ,M=\sum_{v\in V}|d(v)|$. \\
So the complete Mixed Integer Program is:

\begin{align*}
  &\min \sum_{a\in A} w_a\cdot x_a & \\
 s.t. & \sum_{a\in \delta^+(v)}x_a - \sum_{a\in\delta^- (v)}x_a &=& d_v\ &\forall v\in V \\
 & x_a &\le& c_u(a) & \forall a\in A\\
 & x_a &\ge& c_l(a) & \forall a\in A\\
 & \pi_v-\pi_w &\ge & N(\rho_{vw}-1)+1& \forall a=(v,w)\in A\\
 & \pi_v-\pi_w&\le &N\rho_{vw}-1& \forall a=(v,w)\in A\\
 & x_a&\ge& M(\rho_{vw}-1)& \forall a=(v,w)\in A\\
 & x_a&\le & M\rho_{vw}& \forall a=(v,w)\in A\\
 & x_a \in \R & & &\forall a\in A\\
 & \pi_v \in \R & & & \forall v\in V\\
 & d_a \in \{0,1\} & & &\forall a\in A\\
 & \rho_{vw} \in \{0,1\}&&& \forall a=(v,w)\in A\\
\end{align*}
%TODO show that these constraints are equivalent to the nonlinear ones? or make a comment at least?

\subsubsection{Model 2: Acyclicity Constraints On All Cycles}

Another idea to solve the Acyclic Flow Bound Problem 
%(which was partially implemented in Lamatto by Robert Schwarz) 
is the following: Every arc has a direction and the 
sign of the flow on this arc tells us in which direction flow is send over this arc. Again we introduce variables 
$\rho_a\in \{0,1\}$ for each arc $a\in A$ that indicate the direction of flow and are coupled with the flow variables:
\begin{align*}
\rho_a=1 & \Rightarrow x_a\ge 0 \\
\rho_a=0 & \Rightarrow x_a\le 0
\end{align*}
These indicator constraints can be handled the way they are by standard MIP solvers, but to make them real MIP 
constraints we may formulate them as follows (with $M$ a constant sufficient big, e.g. $M=\sum_{v\in V}|d_v|$) :
\begin{align*}
 x_a + M\cdot (1-\rho_a) &\ge 0\\
 x_a - M\cdot \rho_a & \le 0
\end{align*}

In addition to decision variables for the flow direction, we have to add constraints to avoid cycles. If the flow is 
acyclic, each cycle should have at least two arcs with opposite directions. In other words, there has to be one arc
in forward direction and one in backward direction, so with $n:=|C|$ we get as constraint:
$$ 1\le\sum_{a\in C\textrm{ forward }} \rho_a + \sum_{a\in C\textrm{ backward }}1-\rho_a\le n-1$$

Let us formulate this in a slightly different way to get only one sum: For each cycle of size $C_n=C_l+C_m$ 
let $C_m$ be the number of arcs directed forward and $C_l$ the number of arcs directed backward. We define that always 
$C_l\le C_m$, so forward is defined as the direction that more arcs are pointing towards (left or right would only 
make sense in a planar embedding). Then we get the constraint $$1-l \le \sum_{a\in C}\rho_a\le n-(l+1)$$ that forbids 
any cyclic flow on $C$. We will show later under which conditions such constraints also forbid cyclic flow on other 
cycles. 
%TODO was ist wenn gleich viele? Ist das als Definition so ueberhaupt ok?

So our MIP formulation of the model is finally
\begin{align*}
 &\min \sum_{a\in A} w_a\cdot x_a & \\
 s.t. & \sum_{a\in \delta^+(v)}x_a - \sum_{a\in\delta^- (v)}x_a = d_v\ &\forall v\in V \\
  & c_l(a)\le x_a \le c_u(a) & \forall a\in A\\
 &x_a + M\cdot (1-\rho_a) \ge 0 & \forall a\in A\\
 &x_a - M\cdot \rho_a \le 0 & \forall a\in A\\
 &1-l \le \sum_{a\in C}\rho_a \le n-(l+1) & \forall \textrm{ cycle }C\in G\\
 & x_a \in \R &\forall a\in A\\
 & \rho_a \in \{0,1\} &\forall a\in A
\end{align*}
or if we normalize the MIP to only $\le$ inequalities:
\begin{align}
 &\min \sum_{a\in A} w_a\cdot x_a & \\
 s.t. & \sum_{a\in \delta^+(v)}x_a - \sum_{a\in\delta^- (v)}x_a &=& b_v\ &\forall v\in V \\
 & x_a &\le& c_u(a) & \forall a\in A\\
 & -x_a &\le& c_l(a) & \forall a\in A\\
 &-x_a - M\cdot (1-\rho_a) &\le& 0 & \forall a\in A\\
 &x_a - M\cdot \rho_a &\le& 0 & \forall a\in A\\
 &1-l - \sum_{a\in C}\rho_a &\le& 0 & \forall \textrm{ cycle }C\in G\\
 & \sum_{a\in C}\rho_a +(l+1)-n &\le& 0 & \forall \textrm{ cycle }C\in G\\
 & x_a \in \R & & &\forall a\in A\\
 & \rho_a \in \{0,1\} & & &\forall a\in A
\end{align}


\subsection{The number of cycles we have to forbid}
The model above has one obvious problem we have to deal with: Since it has a constraint for every cycle of $G$ and the 
number of cycles in a graph might be exponential, even setting up the model would need exponential running time. 

So do we really need every cycle? Or is it enough to just forbid cyclic flow on a small subset (e.g. a cycle base) of 
the cycles of $G$? 

The figures \ref{bild:reichtkreisbasis1} and \ref{bild:reichtkreisbasis2} %TODO
show that a cycle base works on the easiest possible example, but fails if the problem gets just a bit more complicated:

%Bild/bsp: zwei dreiecke mit einer gemeinsamen seite - auf 2 Kreisen Fluss verbieten reicht TODO
\begin{figure}[h!]
\centering
\begin{tikzpicture}
[scale=2, vertex/.style={circle,fill=black}]
  \begin{scope}[
    decoration={markings,mark=at position 0.5 with {\arrow{triangle 60}}}
    ]
\node (a) at (0,0)[vertex]{};
% \node (stext) at (-0.1, 0.2){s};
\node (b) at (1,1)[vertex]{} ;
\node (c) at (1,-1)[vertex]{};
\node (d) at (2,0)[vertex]{};

\draw[postaction={decorate}] (a) -- (b);
\draw[postaction={decorate}] (b) -- (c);
\draw[postaction={decorate}] (c) -- (a);
\draw[postaction={decorate}] (c) -- (d);
\draw[postaction={decorate}] (d) -- (b);
%beschriftungen
\node (e1) at (0.4,0.6){$e_1$};
\node (e2) at (1.6,0.6){$e_2$};
\node (e3) at (1.6,-0.6){$e_3$};
\node (e4) at (0.4,-0.6){$e_4$};
\node (e5) at (1.15, 0){$e_5$};
% \draw (3) -- (5);
  \end{scope}
\end{tikzpicture}
\caption{Here it suffices to forbid the 2 interior cycles TODO in order to obtain acyclicity}
 \label{bild:reichtkreisbasis1}
\end{figure}
%beweis dass hier wirklich eine Kreisbasis reicht!

Why are the constraints of a cycle base sufficient in this case of figure \ref{bild:reichtkreisbasis1}? 

We see this immediately, when we look at all acyclicity constraints for the 3 cycles contained in the graph:
\begin{align*}
 1 &\le x_1+x_4+x_5\le 2&\\
 1&\le x_2+x_3+x_5\le 2& \iff -2\le -x_2-x_3-x_5\le -1\\
 -1 &\le x_1-x_2-x_3+x_4 \le 1&
\end{align*}
The last inequality is exactly the sum of the two inequalities above. Hence if two are fulfilled, the last one is 
automatically induced by them, it is a redundant constraint.

%BILD : bei einem ``tetraeder''-graphen reicht es nicht, drei der möglichen Kreise zu verbieten!
\begin{figure}[h!]
\centering
\begin{tikzpicture}
[scale=2, vertex/.style={circle,fill=black}]
  \begin{scope}[
    decoration={markings,mark=at position 0.5 with {\arrow{triangle 60}}}
    ]
\node (a) at (0,-0.1)[vertex]{};%center 
\node (b) at (-1,-0.8)[vertex]{} ;
\node (c) at (0,1)[vertex]{};
\node (d) at (1,-0.8)[vertex]{};
% \node(etext) at (1.4,1.6){e};

\draw[postaction={decorate}] (a) -- (b);
\draw[postaction={decorate}] (b) -- (c);
\draw[postaction={decorate}] (c) -- (a);
\draw[postaction={decorate}] (a) -- (d);
\draw[postaction={decorate}] (d) -- (c);
\draw[postaction={decorate}] (b) -- (d);
%bescriftungen
\node (e1) at (-0.6,0.2){$e_1$};
\node (e2) at (0.6,0.2){$e_2$};
\node (e3) at (0.5,-0.55){$e_3$};
\node (e4) at (-0.5, -0.55){$e_4$};
\node (e5) at (-0.1,0.4){$e_5$};
\node (e6) at (0,-0.9){$e_6$};
% \node (e7) at (){e7};
  \end{scope}
\end{tikzpicture}
\caption{In this tetrahedron graph \textbf{no} cycle bases' acyclicity constraints can enforce acyclic flow on the 
whole 
graph}
 \label{bild:reichtkreisbasis2}
\end{figure}
For figure \ref{bild:reichtkreisbasis2} the situation is more complex, though there is only one more arc in the graph. 
But the number of cycles grows exponentially, so we get 7 cycles in this case. Their inequalities are:
\begin{align*}
 1 &\le x_1+x_4+x_5\le 2&\\
 1&\le x_2+x_3+x_5\le 2& \\%\iff -2\le -x_2-x_3-x_5\le -1\\
 -1&\le x_3-x_4-x_6\le 0\\
 -1&\le x_1-x_2-x_6\le 0\\ 
 -1 &\le x_1-x_2-x_3+x_4 \le 1&\\
 0 &\le x_1+x_3+x_5-x_6\le 2\\
 1&\le x_2+x_4+x_5+x_6\le 3\\
\end{align*}
We could choose the three cycles $(e_1 e_5 e_4)$, $(e_2 e_5 e_3)$, $(e_3 \overline{e_6}\, \overline{e_4})$ as a cycle 
base, these cycles induce the first three constraints. By combining the first and second, we directly get the fifth 
inequality $-1 \le x_1-x_2-x_3+x_4 \le 1$ as above (this one is of course still redundant). But if we add inequality 
$3$, the result is 
\begin{align*}
 &&-1 &\le &x_1&-x_2&-x_3&+x_4 &&\le 1\\
 &+&-1&\le &&&x_3&-x_4&-x_6&\le 0\\
 &=&-2&\le&x_1&-x_2&&&-x_6&\le 1
\end{align*}
But the acylicity constraint of the cycle $(e_1 \overline{e_2} \,\overline{e_6})$ is $-1\le x_1-x_2-x_6\le 0$ instead. 
The resulting constraints are not sharp, because the left hand side and the right hand side depend on the length of the 
cycles, which changes while we combine them.

\begin{prop}
 Given two acyclicity constraints $cons_1$ and $cons_2$ of cycles $C_1$ and $C_2$ in $G$. The acyclicity constraint of 
the joint cycle $C=C_1\cup C_2 \setminus \{a\in A| a\in C_1\land a\in C_2 \}$ is the sum of $cons_1$ amd $cons_2$ if 
and only if $C_1$ and $C_2$ have exactly one arc in common (and this arc is directed differently in both 
cycles/constraints).%TODO.
\end{prop}
This proposition shows that a many of the acyclicity constraints in our model are redundant and can be omitted. But 
still the remaining constraints are exponential in the size of $G$.

\begin{proof}
 Assume we are given two cycles $C_1,\,C_2\in G=(V,A)$ with exactly one arc $g\in A$ 
contained in both cycles, and the direction of the cycles such that $g$ is forward in one cycle and backward in the 
other cycle. Without loss of generality we assume it is forward in $C_1$ and backward in $C_2$, i.e. $x_g$ has a 
positive sign in $cons_1:\,lhs_1\le \dots\le rhs_1$ and a negative sign in $cons_2:\, lhs_2\le \dots\le rhs_2$, which 
are the acyclicity constraints of $C_1$ and $C_2$. 

$\Rightarrow :$ 
The acyclicity constraints $lhs \le \dots\le rhs$ are constructed such that always $rhs-lhs=l-2$, $l$ being the length 
of the cycle the constraint belongs to. Consider two cycles $C_1$ and $C_2$ and let $J\subset A=\{a\in A|a\in C_1 
\land a\in C_2 \}$ be the set of arcs that are contained in both cycles, $j:=|J|$. 

If we sum up the constraints $cons_1$ and $cons_2$ of the cycles $C_1$ and $C_2$ we obviously get another constraint,
say $cons_3:\, lhs=lhs_1+lhs_2\le\dots\le rhs_1+rhs_2=rhs$. The length of the joint cycle $C$ is $l=l_1+l_2-2\cdot j$. 
We have 
$$rhs-lhs=rhs_1+rhs_2-lhs_1-lhs_2=\underbrace{rhs_1-lhs_1}_{l_1-2}+\underbrace{rhs_2-lhs_2}_{l_2-2}=l_1+l_2-4$$
It holds
$$l_1+l_2-4=l_1+l_2-2j-2=l-2 \iff j=1$$ 
This means that only if $C_1$ and $C_2$ have exactly one arc in common (i.e. $j=1$), the necessary condition 
$rhs-lhs=l-2$ is fulfilled to get the new acyclicity constraint.

$\Leftarrow :$ Now we have to show that we get a sharp acyclicity constraint every time we sum up two acyclicity 
constraints that have exactly one variable in common, and this has different sign in both constraints (so it cancels 
out). Let $cons_1$ and $cons_2$ be chosen this way and $C_3=C_1\cup C_2\setminus (C_1\cap C_2)$ be the resulting cycle, 
then we get:
\begin{align*}
 &&1&\le &\sum_{a \textrm{ forward in }C_1}x_a + \sum_{a\textrm{ backward in }C_1}{(1-x_a)}&&\le &l_1-1\\
 &+&1&\le &\sum_{a \textrm{ forward in }C_2}x_a + \sum_{a\textrm{ backward in }C_2}{(1-x_a)}&&\le &l_1-1\\
 &=&2&\le &\sum_{a \textrm{ forward in }C_3}x_a +\sum_{a\textrm{ backward in }C_3}{(1-x_a)}+
 &\underbrace{x_a+1-x_a}_{a\in C_1\cap C_2} &\le &l_1+l_2-2\\
 \iff &&1&\le &\sum_{a \textrm{ forward in }C_3}x_a +\sum_{a\textrm{ backward in }C_3}{(1-x_a)}
 &&\le &\underbrace{l_1+l_2-2}_{l_3}-1\\
\end{align*}
which is exactly the acyclicity constraint of the cycle $C_3$.
\end{proof}
%other redundant constraints: if in the middle there is no source or sink
There are still more redundant acyclicity constraints than these. Under certain conditions the acyclicity of smaller 
cycles implies the acyclicity of combined cycles even if there is more than one arc contained in both cycles.

\begin{prop}
 Given two cycles $C_1, C_2$ with a set of shared arcs $J:=\{a\in C_1|a\in C_2\}$ which we assume to have size greater 
than one ($j:=|J|>1$). If $J$ is a path in the graph with no sink or source vertex in the interior, the acyclicity of 
$C_1, C_2$ together implies acyclicity of the cycle $C_3:=C_1\cup C_2\setminus C_1\cap C_2$.
\end{prop}
\begin{proof}
 We prove this via contradiction. If the common arcs $J$ are a path like above, they have flow always in the same 
direction. Suppose $C_1$ and $C_2$ are acyclic, but $C_3$ is not. This means in both $C_1$ and $C_2$ there are arcs 
with different directions on the cycle, while they are all in the same direction on $C_3$. This means, the arcs with 
different direction have to be in the path $J$ of shared arcs of $C_1$ and $C_2$. Hence within the path $J$ there must 
be arcs which are directed oppositely to each other. This can only happen, if one of the vertices in the interior of 
$J$ is a sink or a source. \Lightning
\end{proof}
%verallgemeinerung: teilt ein kreis den graph in zwei teile, dann ist es ausreichend wenn im innern azyklizität gegeben 
%und keine quelle/senke vorhanden ist? (verallgemeinerung von planarem Fall)
We can prove something more general by giving conditions that apply in more cases:
\begin{prop}
 Given a graph $G=(V,A)$ , without loss of generality assumed to be connected, and a cycle $C\subset G$ with the 
following properties:
 \begin{itemize}
  \item $G\setminus C$ is disconnected
  \item Let $G'$ be a connected component of $G\setminus C$ 
  \item $G'$ has no source or sink nodes
  \item $G'\cup C$ consists of cycles whose direct sum is $C$ %TODO is direct sum what I really mean? Define it?
 \end{itemize}
 Then any acyclic orientation of the other cycles than $C$ in $G'\cup C$ implies already the acyclicity of $C$. This 
  means the acyclicity constraint of $C$ is redundant.

\end{prop}
%Beweisen, dass in einem Gebiet ohne Quellen oder Senken (das planar ist?) einfache kreise reichen
\begin{proof}
 Consider only the subgraph $G'\cup C$ and assume $C$ had a cyclic orientation. In $C$ there has to be a chordal path 
through $G'$. Since there are no sources or sinks in $G'$, in fact there must be a \textit{directed} path from one node 
$v_1 \in C$ to another node $v_k\in C$ going through $G'$: starting from any arc incident to a node on $C$ and one in 
$G'$, we will always find another arc from the endnode in the same direction unless we run into a cycle or a 
source/sink node. But since neither exists in $G'$, after a finite number of arcs we come to a node on $C$ again. Thus 
we can always find a directed path in our setting. 

But there are two smaller cycles $C_1$ and $C_2$ if we divide $C$ along this path. $C$ is a directed cycle and the path 
is also directed $\Rightarrow$ so one of the two cycles has to be directed, which contradicts our assumption. 
\Lightning 

Hence we conclude that acyclicity and absence of sources/sinks in the interior of a cycle make its acyclicity 
constraint redundant.
\end{proof}

%remark that this more general proposition is important for the planar case
There are some special cases where the above result can be very helpful and indeed reduce the number of needed 
acylicity constraints to polynomial size. This is not only relevant in theory, but also in practice: a real world gas 
network might have (at least partially) a planar graph representation. Planar graphs fulfill the condition to find a 
cycle which is dividing the graph into different parts easily - each cycle in a planar graph embedding divides the 
graph 
into interior and exterior. If we have only one source and one sink and find an embedding where both are on the outer 
(unbounded) face of the graph, it is sufficient to have the acyclicity constraints only on the face cycles of the 
graph. The same holds for all areas or subgraphs without sources/sinks that are enclosed by a cycle: we only need small 
simple cycles and all other acyclicity constraints are redundant.

% TODO BILD : Bei einem Gitter mit vielen Quellen/Senken sind wir verloren... !
Still we have a problem with the sources and sinks. If there are many of them we still run into exponential numbers of 
acyclicity constraints.

\newpage
\subsection{The Constrained Path Augmentation Model}%TODO kann man so ein modell finden, das mithilfe von constrained 
% shortestpath problemen einen successive shortest path algo zu einem maxflowbound-algo macht? duerfte schwer werden...

The main idea is to design an algorithm that uses path augmentation to saturate the given flow demands. The 
algorithm tries to push as much flow value as possible over the arc where flow is maximized, while having the 
constraint that the resulting flow is acyclic. %TODO geht das ueberhaupt mit succ shortest path?
Algorithms that use path augmentation to compute flows are well known and some of the standard flow algorithms. The 
algorithm of Ford and Fulkerson \cite{Ford-Fulkerson_algo} arising from their Max-Flow-Min-Cut theorem is based on 
source-sink-paths in the network as well as the improved algorithms of Edmonds and Karp \cite{EdmondsKarp1972} or Dinic 
\cite{Dinic1970}. 

If we want to maximize flow over arc $a=(u,v)$ it is not sufficient to just look for a path from our source $s$ to node 
$u$ and one from node $v$ to a sink $t$. If we combine them this could produce cyclic flow, see for example figure 
\ref{bild:cycleFromCombinedPaths}. %TODO BILD

%Bild: combining two paths can produce a cycle TODO noch verbessern... z.b. kreis mit einem loop markieren
\begin{figure}[h!]
\centering
\begin{tikzpicture}
[scale=2, vertex/.style={circle,fill=black},arrow/.style={-latex, shorten >=0.2ex, shorten <=0.2ex}]
  \begin{scope}[
    decoration={markings,mark=at position 0.5 with {\arrow{triangle 60}}}
    ]
\node (a) at (3,0)[vertex]{};
% \node (stext) at (-0.1, 0.2){s};
\node (b) at (2,-0.5)[vertex]{} ;
\node (c) at (2,1)[vertex]{};
\node (s) at (3,2)[vertex]{};
\node (t) at (0,1)[vertex]{};

\draw[postaction={decorate}] (b) -- (a)node [pos=0.5, above, black] {e};
\draw[arrow, bend right, color=red] (s) to (c);
\draw[arrow, bend right, color=red] (c) to (b);
\draw[arrow, bend left, color=orange] (c) to (t);
\draw[arrow, bend right, color=orange] (a) to (c);
  \end{scope}
\end{tikzpicture}
\caption{If we just combine a path from the source to the tail of $e$ and from its head to the sink, we might get 
crossing paths, leading to cyclic flow}
 \label{bild:cycleFromCombinedPaths}
\end{figure}

But it is also not sufficient to just use simple paths: it could as well happen that two different paths intersect in 
such a way that the combination of these paths produces a flow cycle, see figure 
\ref{bild:cycleFromDifferentCombinedPaths}.


\begin{figure}[h!]
\centering
\begin{tikzpicture}
[scale=2, vertex/.style={circle,fill=black},arrow/.style={-latex, shorten >=0.2ex, shorten <=0.2ex}]
  \begin{scope}[
    decoration={markings,mark=at position 0.5 with {\arrow{triangle 60}}}
    ]
\node (a) at (3,0)[vertex]{};
% \node (stext) at (-0.1, 0.2){s};
\node (b) at (2,-0.5)[vertex]{} ;
\node (c) at (2,1)[vertex]{};
\node (d) at (1.5, -2)[vertex]{};
\node (e) at (3.5, -1)[vertex]{};
\node (s) at (3,2)[vertex]{};
\node (t) at (0,1)[vertex]{};

\draw[postaction={decorate}] (b) -- (a)node [pos=0.5, above, black] {e};
\draw[arrow, bend right, color=red] (s) to (c);
\draw[arrow, bend right, color=red] (c) to (b);
\draw[arrow, bend left, color=red] (a) to (e);
\draw[arrow, bend right, color=blue] (c) to (t);
\draw[arrow, bend right, color=blue] (a) to (c);
\draw[arrow, bend left, color=blue] (d) to (b);
  \end{scope}
\end{tikzpicture}
\caption{If we combine two simple paths going over $e$ we might get a crossing, leading to cyclic flow}
 \label{bild:cycleFromDifferentCombinedPaths}
\end{figure}

In order to design an algorithm that uses such path augmentations, it is thus necessary to put acyclicity into the path 
choosing procedure as a constraint. The condition that flow on an arc $e$ is maximized still has to be the objective.
However, if we want to successively search and augment paths in the network it might be necessary to augment flow 
backwards - i.e. to change previosly chosen paths due to an acyclicity issue of the current path.
This is a problem for easy path searching methods. If we have to choose a next node for the path locally and do not 
know if we have to change a previous path we might have to branch on the decisions.  

In this thesis we will not try to deal with this problem. Instead we assume we had a blackbox algorithm giving us 
a path to augment - if necessary augmenting back and by this changing other paths from former iterations - such that
the result is an acyclic flow. We show how such an algorithm could be used to compute an upper bound on the flow on an 

%algo um mit dieser blackbox die optimale flussschranke zu berechnen!






% We have to show that we can model our acyclic path as the ressource constrained shortest path. Still ressource 
% constrained shortest path is $\mathcal{NP}$-hard, %TODO

\input{heuristic}
%%TODO der pfadbasierte heuristische algo funtioniert nicht so einfach, Korrektheit beweisen oder weglassen/auf den 
% anderen schlechteren beziehen...


%Beweisen, dass man mindestens eine bestimmte Anzahl an Kreisen benötigt

% \newpage
% \subsection{A Path-Based Heuristic Approach}
% Since solving big real world instances of Mixed Integer Programs is often slow, we also want to discuss an approach 
% to get weaker results with a heuristic that is running much faster. The goal is still to get upper and lower bounds 
% on the flow over an arc. This is not necessarily an optimal bound but any feasible bound. 
% 
% The main idea is to design an algorithm that uses path augmentation to saturate the given flow demands. The 
% algorithm trys to push as much flow value as possible over the arc where flow is maximized. Algorithms that use path 
% augmentation to compute flows are well known and some of the standard flow algorithms. The algorithm of Ford and 
% Fulkerson \cite{Ford-Fulkerson_algo} arising from their Max-Flow-Min-Cut theorem is based on source-sink-paths in the 
% network as well as the improved algorithms of Edmonds and Karp \cite{EdmondsKarp1972} or Dinic \cite{Dinic1970}. 
% 
% The advantage of this approach is that it is very easy to compute a path from one node to another or to decide that 
% there is none. It can essentially be done by simple graph search algorithms. Some Maximum Flow algorithms use shortest 
% path as subroutine in order to prove their optimality, which in our case would not work: we would set negative weight 
% on the arc to maximize flow. But the shortest path problem is only easy to solve with nonnegative edge weights. With 
% arbitrary negative edge weights it is equivalent to longest path, which is 
% known to be NP-Complete by an easy reduction to hamiltonian path. \cite{}%TODO zitiere eine quelle dazu!
% 
% If we want to maximize flow over arc $a=(u,v)$ we just look for a path from our source $s$ to node $u$ and one from node 
% $v$ to a sink $t$. Of course we have not ensured that the two paths have no arcs or nodes in common, so if we combine 
% them this could produce cyclic flow, see for example figure \ref{bild:cycleFromCombinedPaths}. %TODO BILD
% 
% %Bild: combining two paths can produce a cycle TODO noch verbessern... z.b. kreis mit einem loop markieren
% \begin{figure}[h!]
% \centering
% \begin{tikzpicture}
% [scale=2, vertex/.style={circle,fill=black},arrow/.style={-latex, shorten >=0.2ex, shorten <=0.2ex}]
%   \begin{scope}[
%     decoration={markings,mark=at position 0.5 with {\arrow{triangle 60}}}
%     ]
% \node (a) at (3,0)[vertex]{};
% % \node (stext) at (-0.1, 0.2){s};
% \node (b) at (2,-0.5)[vertex]{} ;
% \node (c) at (2,1)[vertex]{};
% \node (s) at (3,2)[vertex]{};
% \node (t) at (0,1)[vertex]{};
% 
% \draw[postaction={decorate}] (b) -- (a)node [pos=0.5, above, black] {e};
% \draw[arrow, bend right, color=red] (s) to (c);
% \draw[arrow, bend right, color=red] (c) to (b);
% \draw[arrow, bend left, color=blue] (c) to (t);
% \draw[arrow, bend right, color=blue] (a) to (c);
% %beschriftungen
% % \node (e1) at (0.4,0.6){$e_1$};
% % \node (e2) at (1.6,0.6){$e_2$};
% % \node (e3) at (1.6,-0.6){$e_3$};
% % \node (e4) at (0.4,-0.6){$e_4$};
% % \node (e5) at (1.15, 0){$e_5$};
% % \draw (3) -- (5);
%   \end{scope}
% \end{tikzpicture}
% \caption{If we just combine a path from the source to the tail of $e$ and from its head to the sink, we might get 
% crossing paths, leading to cyclic flow}
%  \label{bild:cycleFromCombinedPaths}
% \end{figure}
% 
% But on every path the flow is going over $e$ only once, while in a MIP formulation as normal Min-Cost Flow Problem it 
% could be as much as the capacity of $e$ allows. The heuristic will always fulfill the natural bound that flow over each 
% arc is at most the sum of all ingoing/outgoing flow in the network. Before we can prove anything, we have to deal with 
% the problem that there might be no path between a chosen source-sink pair over the specified arc $e$. In fact it is 
% even worse: Figure \ref{bild:backaugmentationIsNecessary} %TODO make this picture, where we have to go back to saturate 
% shows that situations can occur, where we have to decrease the amount of flow over $e$ within the heuristic to just 
% make our flow a feasible flow. 
% %TODO prove it
% 
% We will specify the heuristic algorithm here in pseudocode and show that it yields a valid bound not higher than the 
% sum of flow from all sources. We will also analyze its worst-case running time.
% 
% %Pseudocode des Algorithmus
% \begin{algorithm}
%  \caption{path based heuristic flow bound algorithm}
% \label{algo:pathHeur}
%  %TODO gehe gerade von vorwärts gerichteter e aus, und maximierung
%  \begin{algorithmic}[5]%[0] means no line numbers, n means every nth line number is displayed
%   \Function{Heuristic}{$G=(V,A),\, e=(u,v)\in A,\, b:V\to \R $}%hier übergabeparameter
%     \State define $b':V\to \R,\, b'(v)\gets 0 \forall v\in V$ \Comment{temporary balances}
%     \State define $f: A\to\R,\, f(v)\gets 0 \forall a\in A$
%     \While {$\neg (b+b'\equiv 0) $}\Comment{while there are active source-sink-pairs}
%       \If{ $c(e)>f(e)$}
% 	\State $P_1\gets $\Call{pathFromSource}{u}
% 	\State $P_2\gets $\Call{pathToSink}{v}
% 	\If{$P_1\ne \emptyset \land P_2\ne \emptyset$}
% 	  \State $P\gets P_1+e+P_2$\Comment{concatenate the paths found}
% 	  \State \Call {maxAugment}{$P$}\label{heur:lineAugCase1}
% 	  \State \textbf{continue}
% 	\EndIf
%       \EndIf
% %       \Else
% 	\State choose $s\in V$ with $b(s)+b'(s)<0$\Comment{source that is still active}
% 	\State $c_{alt}(e)\gets c(e)$\Comment{save old capacity value}
% 	\State $c(e)\gets f(e)$\Comment{make $e$ unaugmentable for a short time}
% 	\State $P\gets$\Call{pathToSink}{$s$}\Comment{try finding a path that avoids $e$}
% 	\State $c(e)\gets c_{alt}(e)$
% 	\If{$P\ne \emptyset$}
% 	  \State \Call {maxAugment}{$P$}\label{heur:lineAugCase2}
% 	  \State \textbf{continue}
% 	\Else
% 	  \State $P\gets$ \Call{pathToSink}{$s$}
% 		\Comment{try to find any path, at this point of time it will be decreasing the flow on $e$}
% 	  \If{$P\ne \emptyset$}
% 	    \State \Call {maxAugment}{$P$}\label{heur:lineAugCase3}
% 	    \State \textbf{continue}
% 	  \Else
% 	    \State \Return problem infeasible
% 	  \EndIf
% 	\EndIf
%     \EndWhile
%     \State \Return $f(e)$
%   \EndFunction
%   \algstore{heur}
%  \end{algorithmic}
% 
% \end{algorithm}%TODO die aufgerufenen Methoden ebenfalls als Pseudocode darstellen?
% The algorithm calls some easy functions where the name already tells what should be happening there. Though they are 
% simple we also describe them as short pseudocode:
% 
% \begin{algorithm}
% %  \caption{find a path from given node to a source}
%  \begin{algorithmic}\algrestore{heur}
%   \Function{pathFromSource}{$u\in V$}
%     \State define label visited on all nodes false
% %     \State $v\gets 0 \,\forall v\in V$
%     \State define map pred: $V\to V$
%     \State $Q\gets $ empty queue data structure
%     \State $Q\gets u$
%     \While{$Q \ne \emptyset$}
%       \State $tmp\gets Q.pop()$
%       \ForAll{neighbors $n$ of $tmp$}
% 	\If{cannot send flow from $n$ to $tmp$, i.e. $c((n,tmp))=f((n,tmp))$}
% 	  \State \textbf{continue}
% 	\ElsIf{$n$ not visited}
% 	  \State $n\gets$ visited
% 	  \State $pred(n)\gets tmp$
% 	  \State $Q\gets n$
% 	  \If{ $b(n)+b'(n)<0$}\Comment{active source}
% 	    \State\Return path of predecessors from $n$
% 	  \EndIf
% 	\EndIf
%       \EndFor
%     \EndWhile
%   
%   \EndFunction
%  \end{algorithmic}
%  
% \end{algorithm}
% \begin{algorithm}
%  \begin{algorithmic}
%   \Function{pathToSink}{$v\in V$}\Comment{like pathFromSource backwards}
%     \State define label visited on all nodes false
% %     \State $v\gets 0 \,\forall v\in V$
%     \State define map pred: $V\to V$
%     \State $Q\gets $ empty queue data structure
%     \State $Q\gets u$
%     \While{$Q \ne \emptyset$}
%       \State $tmp\gets Q.pop()$
%       \ForAll{neighbors $n$ of $tmp$}
% 	\If{cannot send flow from $tmp$ to $n$, i.e. $c((tmp,n))=f((tmp,n))$}
% 	  \State \textbf{continue}
% 	\ElsIf{$n$ not visited}
% 	  \State $n\gets$ visited
% 	  \State $pred(n)\gets tmp$
% 	  \State $Q\gets n$
% 	  \If{ $b(n)+b'(n)>0)$}\Comment{active sink}
% 	    \State\Return path of predecessors from $n$
% 	  \EndIf
% 	\EndIf
%       \EndFor
%     \EndWhile
%   
%   \EndFunction
%  \end{algorithmic}
% \end{algorithm}
% \begin{algorithm}
%  \begin{algorithmic}
%   \Function {maxAugment}{$P$}
%     \State $s\gets $ source node of $P$
%     \State $t\gets $ sink node of $P$
%     \State augval $\gets \min(|s|,|t|)$
%     \ForAll{$a\in P$}
%       \State arcMaxAugval $\gets$ max augmentable flow in direction of $P$ on $a$ 
%       \State augval $\gets \min($augval, arcMaxAugval)
%     \EndFor
%     \ForAll{$a\in P$}
%       \If{$a$ is considered the second time in the same direction in $P$}
% 	\State \textbf{continue}\Comment do not increase flow value here, equivalent to increase of capacity bounds on 
% 		this arc. Why this is necessary see example \ref{example:mustNotAugmentArcTwice}
%       \EndIf
%       \State increase flow on $a$ in direction of $P$ by augval
%     \EndFor
%     \State $b'(s)\gets b'(s) + $augval
%     \State $b'(t)\gets b'(t) - $augval
%   \EndFunction
%  \end{algorithmic}
%  
% \end{algorithm}
% 
% 
% \newpage 
% \subsubsection{Correctness of the heuristic}
% Now we want to show that this algorithm is correct and always yields the result we desire. We have to show that the 
% bounds are valid and include all feasible solutions and that the algorithm terminates within (a small) finite running 
% time.
% 
% %Lemma: if graph search like in the algorithm does not find a way, there is no way!
% \begin{lemma}\label{lemma:graphSearch}
%  The graph search included in algorithm \ref{algo:pathHeur} finds a path from one node to another with the specified 
% characteristics (to source or to sink, forward or backward) if and only if there exists any such path.
% \end{lemma}
% \begin{proof}
%  TODO
% \end{proof}
% 
% 
% 
% %correctness proof
% \begin{prop}
%  The output of algorithm \ref{algo:pathHeur} is a valid upper bound on the acyclic flow over the given arc $e$. 
%  
%  It is at most $\sum_{v\in V|b(v)>0\textrm{ source}}b(v)=-\sum_{v\in V|b(v)<0\textrm{ sink}}b(v)$ on each arc.
% \end{prop}
% \begin{proof}
%  %start new proof and comment out the old messed up one
%  We show correctness for each stage of the algorithm. This means we show that at each augmentation step the flow value 
% on the maximized arc $e$ is at least as high as the maximum value in any acyclic flow satifying the same supply and 
% demand. There are three stages: at first we try to send all flow over the maximized arc $e$. In the second step this is 
% not possible anymore (as we show) so we try to find paths to augment where $e$ is not affected at all. In the last step 
% we can try to satify all supply/demand in the network, accepting that it might decrease flow value on $e$. We show that 
% this is correct and yields improved bounds. We also have to show that we can not go back to a former stage after 
% completing it.
% \begin{itemize}
%  \item [First Stage (Forward augmentation on $e$, alg. line \ref{heur:lineAugCase1}) :] In step $i$ an additional 
% supply and demand of say $\alpha_i$ gets satisfied. In each of the 
% steps the flow value $f_i(e)$ on the maximized arc $e$ is also increased by $\alpha_i$. So while the algorithm is in 
% this stage it has all flow going over $e$. In any acyclic flow this flow value can not be higher: if in an acyclic flow 
% $f'_i(e)$ the flow value was higher than $f_i(e)$, flow from one source would have to go over $e$ twice. But this 
% would form a cyclic flow somewhere. \Lightning.
% 
%   \item[Second Stage (Cannot increase flow over $e$, but can go around, alg. line \ref{heur:lineAugCase2}) :]
%   
%   
%   \item[Third Stage (Cannot find a path that is not decreasing $f(e)$, alg. line \ref{heur:lineAugCase3}) :] 
% \end{itemize}
% 
%  
%  
%  
% \end{proof}
% 
% 
% 
% 
% 
% 
% 
% 
% 
% 
% % 
% % \begin{proof}%the old proof 
% %   Let $\overline{f(e)}$ be the upper bound on $e$ returned by the heuristic algorithm. We show that there is no 
% %   feasible acyclic flow $f'$ such that $f'(e)>\overline{f(e)}$:
% %   
% %   We will prove this by mathematical induction over the steps of the algorithm. Denote the current balances of step $i$ 
% %   by $b_i'$ and the corresponding flow in the heuristics $i$th step by $f_i$.
% %   \begin{itemize}
% %    \item[Induction Hypothesis:] Given the balances $b_i'$ it always holds: 
% %       $$\nexists \textrm{ feasible flow }f_{b_i'}':A\to \R\textrm{ s.t. }f'_{b_i'}(e) > f_i(e)$$
% %    \item[Basis:] This is true for $b_0'$: We set $b_0'\equiv 0$ , so there are no sources and sinks. Hence the only 
% %       feasible acyclic flow $f'$ is the constant $0$ flow. This is also exactly how the algorithm defined $f_0$ in the 
% %       initialization, so $f_0\equiv f_{b_0'}'$.
% %    \item[Inductive Step:] Assume $f_{b_{i-1}'}'(e)\le f_{i-1}(e)$ for all feasible $f'_{b_{i-1}'}$. Now in step $i$ the 
% %       algorithm computes a path between a source $s_i$ and a sink $t_i$ and updates the balances at these two nodes by 
% %       the augmentation value $\alpha_i$.
% %       We have to analyze three cases in the algorithm how the augmented path is found and what happens in each case 
% %       with the flow on arc $e$.
% %       \begin{enumerate}
% %        \item Case: (Forward augmentation on $e$, alg. line \ref{heur:lineAugCase1}) In the first case we found a path 
% % 	  over $e$ where we can augment an amount of $\alpha_i$. Thus $f_i(e)=f_{i-1}(e)+\alpha_i$. 
% % 	  Assume we had a flow $f'$ with $f_{b_{i}'}'(e)> f_{i}(e)$. If we subtract (i.e. augment backwards) $\alpha_i$
% % 	  on the path found in step $i$, we obtain a flow that is feasible for the balances $b_{i-1}'$. On $e$ this 
% % 	  flow has a flow value of $f_{b_i'}(e)-\alpha_i$. But this gives 
% % 	  $$f_i(e)-\alpha_i =f_{i-1}(e)\ge f'_{b_{i-1}'}= f_{b_i'}'(e)-\alpha_i > f_{i}(e)-\alpha_i$$
% % 	  which is clearly a contradiction. \Lightning
% %        \item Case: (Cannot increase flow over $e$, but can go around, alg. line \ref{heur:lineAugCase2}) 
% % 	  In this case either the graph search did not find any path going over $e$ or $e$ is at its capacity bound. 
% % 	  If $e$ is at its capacity bound, it is obvious that there is no feasible flow with more flow on $e$.
% % 	  
% % 	  Consider the case the graph search did not find any augmentable path from the head or to the tail of $e$. 
% % 	  To make it easier we assume we did not find a path from the head $v$ of $e$ to an active sink, it works the 
% % 	  same way for a backward path to an active source.
% % 	  Lemma \ref{lemma:graphSearch} tells us that in this case there really is no augmentable path from $v$ to any 
% % 	  active sink. The only ways from $v$ that are ignored by the graph search are the ones going from $v$ over 
% % 	  $e$. So if we consider the digraph of augmentable arcs of $G$ there is a directed cut between $v$ and every 
% % 	  active sink. But this means that $e$ has reached its absolute maximum flow, since always the minimum size of
% % 	  a cut is greater or equal the size of a flow through a network. 
% % 	  %TODO kommt mir schwammig vor, zitiere oder beweisen?
% % 	  So also every other flow $f'$ cannot have a greater value on $e$. In this case if we have any path that is 
% % 	  not decreasing the flow value on $e$ it is a good choice to augment it. 
% % 	  
% %        \item Case: (Cannot find a path that is not decreasing $f(e)$, alg. line \ref{heur:lineAugCase3} )
% % 	  In this case we searched for a path from a source to any sink, and the only one we found was going backwards 
% % 	  over $e$. So if we would delete $e$ there would be a directed cut in the graph of augmentable arcs between 
% % 	  the source and the part(s) of the graph with all sinks. Thus sending flow back on $e$ is the only possibility 
% % 	  to increase flow value on this directed cut.
% % %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%	  
% % % 	  Now we augment the maximum value $\alpha_i$ on this path to get a feasible flow on the balances 
% % % 	  $b_i$. If there would be any better flow $f_{b_{i}'}'(e)> f_{i}(e)$ again - like in the cases before - this 
% % % 	  would yield also a better flow $f_{b_{i-1}'}'(e)> f_{i-1}(e)$ by augmenting back $\alpha_i$ on the path.  
% % % 	  %TODO das argument müsste noch zeigen, dass die rückaugmentierung keine kapazitätsschranken verletzt!
% %       \end{enumerate}
% % 
% %   \end{itemize}
% % 
% % 
% % %   Let $f:A\to \R$ be the flow computed in the algorithm at the moment when it returned $\overline{f(e)}$. $f$ and $f'$ 
% % % are two flows on the same network with the same in- and outflow, so the difference between them $f-f'$ is just a cyclic 
% % % flow without sources or sinks. We can thus transform them into each other by a sequence of cyclic augmentations.
% % \end{proof}
% 
% %Laufzeit
% \begin{prop}
%  Algorithm \ref{algo:pathHeur} always terminates after at most $\mathcal{O}()$ steps.
% \end{prop}
