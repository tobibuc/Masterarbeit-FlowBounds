%main section about the different models 
In this section we describe different mathematical models that can be used to obtain bounds on the acyclic flow going 
over a specified arc of the given flow network (assumed there is any feasible network flow). We present two different 
MIP models of the acyclic flowbound problem. The first model uses node potentials and constraints to force flow to 
go in direction from higher to lower potentials. The second model uses decision variables for the direction of the 
flow and special acyclicity constraints on them for each cycle. They are different in size as the second MIP model 
explicitly uses constraints on the cycles to exclude cyclic flow from the solution. We show that it is not sufficient 
to have these constraints just on a cycle base (which would be a linearly small number). But we can prove 
conditions under which the acyclicity constraint of a cycle becomes redundant. Still there can be exponential many 
cycles in a network and the condition could be fulfilled on \textit{cycle} of the network. 

Furthermore we discuss an idea to solve the problem with a direct algorithm augmenting paths. We show by examples that 
path augmentation alone can not solve the problem, but the idea inspires a relaxation/heuristic algorithm which runs in 
polynomial time.


\subsection{MIP Formulations}
For many combinatorial Problems it is the best practical solution to formulate them as a Mixed Integer Problem and just 
solve this problem with modern MIP Solvers such as CPlex, Gurobi, SCIP etc. Often there are different possible 
formulations of the problem as 
MIP, which might yield very different running times due to numerical or algorithmical reasons. In our problem, it is 
easy to model the flow conservation and the ingoing and outgoing flow on vertices. Like described before, we can assign 
a negative weight to an arc variable and this way maximize flow over this arc by minimizing the overall cost. This 
would be the typical MIP formulation of a min cost flow:

\begin{align*}
  &\min \sum_{a\in A} w_a\cdot q_a  \\
  %TODO an die balance-intervall formulierung anpassen
 s.t. & \sum_{a\in \delta^+(v)}q_a - \sum_{a\in\delta^- (v)}q_a = d_v\ &\forall v\in V \\
  & c_l(a)\le q_a \le c_u(a) & \forall a\in A
\end{align*}

This model still allows cyclic flow, so we have to find constraints to avoid cyclicity. 
\subsubsection{Model 1: Node Potentials}
\label{model:nodePotential}
%TODO welche formulierungen koennte es noch geben fuer dieses problem?
%TODO PORTA results and polytope of the problem?

One idea (that is unfortunately not a linear problem formulation anymore) would be to set potentials on the nodes and 
allow only flow from higher to lower potential. This is quite close to the application of our problem in gas flow 
computation, where gas will only flow from places with high pressure to places with lower pressure in the network. So 
each vertex $v$ would get a variable $\pi_v$ for its potential, each arc $a$ as before a variable $q_a$ for the amount 
of flow. Then we add the constraint $$q_a\cdot (\pi_v -\pi_w)\ge 0\,\forall a=(v,w)\in A $$
We have to ensure that the values of the potentials are all 
different, or that there is no flow between nodes of the same potential. Otherwise any solution where all potentials 
are set to the same value would fulfill this constraint, regardless if it is acyclic or not. So in practice we could 
set a constant $\varepsilon > 0$ to describe the minimum distance between the potentials. A feasible 
solution now has to fulfill the constraint above on every arc. If we set up the constraint as above, we get the Mixed 
Integer Nonlinear Program

\begin{align*}\label{model:nodePotentialQuadratic}
  &\min \sum_{a\in A} w_a\cdot q_a & \\
 s.t. & \sum_{a\in \delta^+(v)}q_a - \sum_{a\in\delta^- (v)}q_a &=& d_v\ &\forall v\in V \\
 & q_a &\le& c_u(a) & \forall a\in A\\
 & -q_a &\le& c_l(a) & \forall a\in A\\
 & -q_a\cdot (\pi_v -\pi_w)&\le& 0 &\forall a=(v,w)\in A\\
 & (\pi_v - \pi_w)^2 &\ge& \varepsilon &\forall v,w \in V\\
 & q_a \in \R & & &\forall a\in A\\
 & \pi_v \in \R & & & \forall v\in V\\
 & d_a \in \{0,1\} & & &\forall a\in A\\
\end{align*}

We show that this flow indeed is an acyclic one:

\begin{prop}
 A flow which fulfills the constraints of the above nonlinear program is always acyclic.
\end{prop}
\begin{proof}
 Assume a flow fulfilling the above constraints would have cyclic flow on a cycle $C$. Without loss of generality 
we label the vertices on the cycle from $1$ to $n$ and assume all arcs are directed forward on this cycle. This means 
there are arcs $a_1=(v_1,v_2),a_2=(v_2,v_3), \dots a_n=(v_n, v_1)\in C$ such that $q_{a_i} > 0 \,\forall i={1,\dots , 
n}$. Also we know from the constraints  $q_a\cdot (\pi_v -\pi_w)\ge 0$ and $\pi_v - \pi_w \neq 0$ (Hence $\Rightarrow 
\pi_v\neq\pi_w)\, \forall v,w\in V$. So we conclude an ordering of the vertices potentials: $q_{a_1}\cdot (\pi_{v_1} 
-\pi_{v_2})\ge 0 \Rightarrow \pi_{v_1}>\pi_{v_2}$ and so on. This yields a sequence $\pi_{v_1}>\pi_{v_2}>\dots 
>\pi_{v_n}>\pi_{v_1}$, which is a contradiction. \Lightning
\end{proof}

However, solving nonlinear mixed integer programs comes with many difficulties, so we will use indicator constraints 
or an equivalent Big-M constraint to get a mixed integer formulation avoiding these difficulties. For this we  replace 
$$q_a\cdot (\pi_w -\pi_v)\le 0 \,\forall a=(v,w)\in A $$ and $$(\pi_v - \pi_w)^2 \ge \varepsilon \,\forall v,w \in V$$

%introduce rho (=richtung) variables
Instead we introduce a new binary variable $\rho_{vw}$ to indicate the flow direction on $a=(v,w)$, and say this 
variable has to be 1 if flow is from $v$ to $w$ and 0 if it is from $w$ to $v$. Also if $\rho_{vw}$ is $1$ the 
potential $\pi_v$ of $v$ has to be greater than the potential $\pi_w$ of $w$ and the other way around. So with 
indicatorconstraints we get 

% \label{model:nodePotentialIndicator}
\begin{align*}
 &\rho_{vw}=1 &\Rightarrow &\pi_v\ge\pi_w +1\\
 &\rho_{vw}=0 &\Rightarrow &\pi_w\ge\pi_v +1\\
 &\rho_{vw}=1 &\Rightarrow &q((v,w))\ge 0\\
 &\rho_{vw}=0 &\Rightarrow &q((v,w))\le 0\\
 &\rho_{vw} \in \{0,1\}&&
\end{align*}
We can reformulate these indicator constraints as

%  \label{model:nodePotentialBigM}
\begin{align*}
 &\pi_v-\pi_w &\ge & N(\rho_{vw}-1)+1\\
 &\pi_v-\pi_w&\le &N\rho_{vw}-1 \\
 &q((v,w))&\ge& M(\rho_{vw}-1)\\
 &q((v,w))&\le & M\rho_{vw}\\
 &\rho_{vw} \in \{0,1\}&&\\
\end{align*}
where $N\in \R$ and $M\in \R$ are sufficient big constants. Sufficient big in this case could mean we choose 
$N=|V|\, ,M=\sum_{v\in V}|d(v)|$. \\
So the complete Mixed Integer Program is:

% \label{model:nodePotentialWithBigM}
\begin{align*}
  &\min \sum_{a\in A} w_a\cdot q_a & \\
 s.t. & \sum_{a\in \delta^+(v)}q_a - \sum_{a\in\delta^- (v)}q_a &=& d_v\ &\forall v\in V \\
 & q_a &\le& c_u(a) & \forall a\in A\\
 & q_a &\ge& c_l(a) & \forall a\in A\\
 & \pi_v-\pi_w &\ge & N(\rho_{vw}-1)+1& \forall a=(v,w)\in A\\
 & \pi_v-\pi_w&\le &N\rho_{vw}-1& \forall a=(v,w)\in A\\
 & q_a&\ge& M(\rho_{vw}-1)& \forall a=(v,w)\in A\\
 & q_a&\le & M\rho_{vw}& \forall a=(v,w)\in A\\
 & q_a \in \R & & &\forall a\in A\\
 & \pi_v \in \R & & & \forall v\in V\\
 & d_a \in \{0,1\} & & &\forall a\in A\\
 & \rho_{vw} \in \{0,1\}&&& \forall a=(v,w)\in A\\
\end{align*}
%TODO show that these constraints are equivalent to the nonlinear ones? or make a comment at least?

\subsubsection{Model 2: Acyclicity Constraints On All Cycles}
\label{model:AcyclicityConstraints}
Another idea to solve the Acyclic Flow Bound Problem 
%(which was partially implemented in Lamatto by Robert Schwarz) 
is the following: Every arc has a direction and the 
sign of the flow on this arc tells us in which direction flow is send over this arc. Again we introduce variables 
$\rho_a\in \{0,1\}$ for each arc $a\in A$ that indicate the direction of flow and are coupled with the flow variables:
\begin{align*}
\rho_a=1 & \Rightarrow q_a\ge 0 \\
\rho_a=0 & \Rightarrow q_a\le 0
\end{align*}
These indicator constraints can be handled the way they are by standard MIP solvers, but to make them real MIP 
constraints we may formulate them as follows (with $M$ a constant sufficient big, e.g. $M=\sum_{v\in V}|d_v|$) :
\begin{align*}
 q_a + M\cdot (1-\rho_a) &\ge 0\\
 q_a - M\cdot \rho_a & \le 0
\end{align*}

In addition to decision variables for the flow direction, we have to add constraints to avoid cycles. If the flow is 
acyclic, each cycle should have at least two arcs with opposite directions. In other words, there has to be one arc
in forward direction and one in backward direction, so with $n:=|C|$ we get as constraint:
$$ 1\le\sum_{a\in C\textrm{ forward }} \rho_a + \sum_{a\in C\textrm{ backward }}1-\rho_a\le n-1$$

Let us formulate this in a slightly different way to get only one sum: For each cycle of size $C_n=C_l+C_m$ 
let $C_m$ be the number of arcs directed forward and $C_l$ the number of arcs directed backward. We define that always 
$C_l\le C_m$, so forward is defined as the direction that more arcs are pointing towards (left or right would only 
make sense in a planar embedding). Then we get the constraint $$1-l \le \sum_{a\in C}\rho_a\le n-(l+1)$$ that forbids 
any cyclic flow on $C$. We will show later under which conditions such constraints also forbid cyclic flow on other 
cycles. 
%TODO was ist wenn gleich viele? Ist das als Definition so ueberhaupt ok?

So our MIP formulation of the model is finally
\begin{align*}
 &\min \sum_{a\in A} w_a\cdot q_a & \\
 s.t. & \sum_{a\in \delta^+(v)}q_a - \sum_{a\in\delta^- (v)}q_a = d_v\ &\forall v\in V \\
  & c_l(a)\le q_a \le c_u(a) & \forall a\in A\\
 &q_a + M\cdot (1-\rho_a) \ge 0 & \forall a\in A\\
 &q_a - M\cdot \rho_a \le 0 & \forall a\in A\\
 &1-l \le \sum_{a\in C}\rho_a \le n-(l+1) & \forall \textrm{ cycle }C\in G\\
 & q_a \in \R &\forall a\in A\\
 & \rho_a \in \{0,1\} &\forall a\in A
\end{align*}
or if we normalize the MIP to only $\le$ inequalities:
\begin{align}
 &\min \sum_{a\in A} w_a\cdot q_a & \\
 s.t. & \sum_{a\in \delta^+(v)}q_a - \sum_{a\in\delta^- (v)}q_a &=& b_v\ &\forall v\in V \\
 & q_a &\le& c_u(a) & \forall a\in A\\
 & -q_a &\le& c_l(a) & \forall a\in A\\
 &-q_a - M\cdot (1-\rho_a) &\le& 0 & \forall a\in A\\
 &q_a - M\cdot \rho_a &\le& 0 & \forall a\in A\\
 &1-l - \sum_{a\in C}\rho_a &\le& 0 & \forall \textrm{ cycle }C\in G\\
 & \sum_{a\in C}\rho_a +(l+1)-n &\le& 0 & \forall \textrm{ cycle }C\in G\\
 & q_a \in \R & & &\forall a\in A\\
 & \rho_a \in \{0,1\} & & &\forall a\in A
\end{align}


\subsection{The number of cycles we have to forbid}
The model above has one obvious problem we have to deal with: Since it has a constraint for every cycle of $G$ and the 
number of cycles in a graph might be exponential, even setting up the model would need exponential running time. 

So do we really need every cycle? Or is it enough to just forbid cyclic flow on a small subset (e.g. a cycle base) of 
the cycles of $G$? 

The figures \ref{bild:reichtkreisbasis1} and \ref{bild:reichtkreisbasis2} %TODO
show that a cycle base works on the easiest possible example, but fails if the problem gets just a bit more complicated:

%Bild/bsp: zwei dreiecke mit einer gemeinsamen seite - auf 2 Kreisen Fluss verbieten reicht TODO
\begin{figure}[h!]
\centering
\begin{tikzpicture}
\node (a) at (0,0)[vertex]{};
% \node () at (-0.1, 0.2){};
\node (b) at (1,1)[vertex]{} ;
\node (c) at (1,-1)[vertex]{};
\node (d) at (2,0)[vertex]{};

\draw[arc] (a) -- (b)node [pos=0.5, above]{$e_1$};
\draw[arc] (b) -- (c)node [pos=0.5, left]{$e_2$};
\draw[arc] (c) -- (a)node [pos=0.5, above]{$e_3$};
\draw[arc] (c) -- (d)node [pos=0.5, above]{$e_4$};
\draw[arc] (d) -- (b)node [pos=0.5,above]{$e_5$};
%draw circle with arrowtip
\draw[ultra thick, ->, red!50] (1.65,0) arc (0:290:0.25);
\draw[ultra thick, ->, red!50] (0.8,0.15) arc (30:310:0.25);
\end{tikzpicture}
\caption{Here it suffices to forbid the 2 interior cycles marked with red in order to obtain acyclicity}
\label{bild:reichtkreisbasis1}
\end{figure}
%beweis dass hier wirklich eine Kreisbasis reicht!

Why are the constraints of a cycle base sufficient in this case of figure \ref{bild:reichtkreisbasis1}? 

We see this immediately, when we look at all acyclicity constraints for the 3 cycles contained in the graph:
\begin{align*}
 1 &\le x_1+x_4+x_5\le 2&\\
 1&\le x_2+x_3+x_5\le 2& \iff -2\le -x_2-x_3-x_5\le -1\\
 -1 &\le x_1-x_2-x_3+x_4 \le 1&
\end{align*}
The last inequality is exactly the sum of the two inequalities above. Hence if two are fulfilled, the last one is 
automatically induced by them, it is a redundant constraint.

%BILD : bei einem ``tetraeder''-graphen reicht es nicht, drei der möglichen Kreise zu verbieten!
\begin{figure}[h!]
\centering
\begin{tikzpicture}
\node (a) at (0,-0.1)[vertex]{};%center 
\node (b) at (-1,-0.8)[vertex]{} ;
\node (c) at (0,1)[vertex]{};
\node (d) at (1,-0.8)[vertex]{};
% \node(etext) at (1.4,1.6){e};

\draw[arc] (a) -- (b)node [pos=0.5, above]{$e_4$};
\draw[arc] (b) -- (c)node [pos=0.5, above]{$e_1$};
\draw[arc] (c) -- (a)node [pos=0.5, above]{$e_5$};
\draw[arc] (a) -- (d)node [pos=0.5, above]{$e_3$};
\draw[arc] (d) -- (c)node [pos=0.5, above]{$e_2$};
\draw[arc] (b) -- (d)node [pos=0.5, below]{$e_6$};
\end{tikzpicture}
\caption{In this tetrahedron graph \textbf{no} cycle bases' acyclicity constraints can enforce acyclic flow on the 
whole 
graph}
 \label{bild:reichtkreisbasis2}
\end{figure}
For figure \ref{bild:reichtkreisbasis2} the situation is more complex, though there is only one more arc in the graph. 
But the number of cycles grows exponentially, so we get 7 cycles in this case. Their inequalities are:
\begin{align*}
 1 &\le x_1+x_4+x_5\le 2&\\
 1&\le x_2+x_3+x_5\le 2& \\%\iff -2\le -x_2-x_3-x_5\le -1\\
 -1&\le x_3-x_4-x_6\le 0\\
 -1&\le x_1-x_2-x_6\le 0\\ 
 -1 &\le x_1-x_2-x_3+x_4 \le 1&\\
 0 &\le x_1+x_3+x_5-x_6\le 2\\
 1&\le x_2+x_4+x_5+x_6\le 3\\
\end{align*}
We could choose the three cycles $(e_1 e_5 e_4)$, $(e_2 e_5 e_3)$, $(e_3 \overline{e_6}\, \overline{e_4})$ as a cycle 
base, these cycles induce the first three constraints. By combining the first and second, we directly get the fifth 
inequality $-1 \le x_1-x_2-x_3+x_4 \le 1$ as above (this one is of course still redundant). But if we add inequality 
$3$, the result is 
\begin{align*}
 &&-1 &\le &x_1&-x_2&-x_3&+x_4 &&\le 1\\
 &+&-1&\le &&&x_3&-x_4&-x_6&\le 0\\
 &=&-2&\le&x_1&-x_2&&&-x_6&\le 1
\end{align*}
But the acylicity constraint of the cycle $(e_1 \overline{e_2} \,\overline{e_6})$ is $-1\le x_1-x_2-x_6\le 0$ instead. 
The resulting constraints are not sharp, because the left hand side and the right hand side depend on the length of the 
cycles, which changes while we combine them.

Due to symmetry in this complete graph it does not matter which cycles we choose for the cycle base. In fact there is 
no combination of three cycles that could completely exclude cyclic flow solutions from the solution space.

\begin{prop}
\label{prop:redundantAcyclicityCons}
 Given two acyclicity constraints $cons_1$ and $cons_2$ of cycles $C_1$ and $C_2$ in $G$. The acyclicity constraint of 
the joint cycle $C=C_1\cup C_2 \setminus \{a\in A| a\in C_1\land a\in C_2 \}$ is the sum of $cons_1$ amd $cons_2$ if 
and only if $C_1$ and $C_2$ have exactly one arc in common (and this arc is directed differently in both 
cycles/has different sign in both constraints).
\end{prop}
This proposition shows that many of the acyclicity constraints in our model may be redundant and could be omitted. 
But still the remaining constraints are exponential in the size of $G$.

\begin{proof}
 Assume we are given two cycles $C_1,\,C_2\in G=(V,A)$ with exactly one arc $g\in A$ 
contained in both cycles, and the direction of the cycles such that $g$ is forward in one cycle and backward in the 
other cycle. Without loss of generality we assume it is forward in $C_1$ and backward in $C_2$, i.e. $x_g$ has a 
positive sign in $cons_1:\,lhs_1\le \dots\le rhs_1$ and a negative sign in $cons_2:\, lhs_2\le \dots\le rhs_2$, which 
are the acyclicity constraints of $C_1$ and $C_2$. 

$\Rightarrow :$ 
The acyclicity constraints $lhs \le \dots\le rhs$ are constructed such that always $rhs-lhs=l-2$, $l$ being the length 
of the cycle the constraint belongs to. Consider two cycles $C_1$ and $C_2$ and let $J\subset A=\{a\in A|a\in C_1 
\land a\in C_2 \}$ be the set of arcs that are contained in both cycles, $j:=|J|$. 

If we sum up the constraints $cons_1$ and $cons_2$ of the cycles $C_1$ and $C_2$ we obviously get another constraint,
say $cons_3:\, lhs=lhs_1+lhs_2\le\dots\le rhs_1+rhs_2=rhs$. The length of the joint cycle $C$ is $l=l_1+l_2-2\cdot j$. 
We have 
$$rhs-lhs=rhs_1+rhs_2-lhs_1-lhs_2=\underbrace{rhs_1-lhs_1}_{l_1-2}+\underbrace{rhs_2-lhs_2}_{l_2-2}=l_1+l_2-4$$
It holds
$$l_1+l_2-4=l_1+l_2-2j-2=l-2 \iff j=1$$ 
This means that only if $C_1$ and $C_2$ have exactly one arc in common (i.e. $j=1$), the necessary condition 
$rhs-lhs=l-2$ is fulfilled to get the new acyclicity constraint.

$\Leftarrow :$ Now we have to show that we get a sharp acyclicity constraint every time we sum up two acyclicity 
constraints that have exactly one variable in common, and this has different sign in both constraints (so it cancels 
out). Let $cons_1$ and $cons_2$ be chosen this way and $C_3=C_1\cup C_2\setminus (C_1\cap C_2)$ be the resulting cycle, 
then we get:
\begin{align*}
 &&1&\le &\sum_{a \textrm{ forward in }C_1}q_a + \sum_{a\textrm{ backward in }C_1}{(1-q_a)}&&\le &l_1-1\\
 &+&1&\le &\sum_{a \textrm{ forward in }C_2}q_a + \sum_{a\textrm{ backward in }C_2}{(1-q_a)}&&\le &l_1-1\\
 &=&2&\le &\sum_{a \textrm{ forward in }C_3}q_a +\sum_{a\textrm{ backward in }C_3}{(1-q_a)}+
 &\underbrace{q_a+1-q_a}_{a\in C_1\cap C_2} &\le &l_1+l_2-2\\
 \iff &&1&\le &\sum_{a \textrm{ forward in }C_3}q_a +\sum_{a\textrm{ backward in }C_3}{(1-q_a)}
 &&\le &\underbrace{l_1+l_2-2}_{l_3}-1\\
\end{align*}
which is exactly the acyclicity constraint of the cycle $C_3$.
\end{proof}
%other redundant constraints: if in the middle there is no source or sink
There are still more redundant acyclicity constraints than these. Under certain conditions the acyclicity of smaller 
cycles implies the acyclicity of combined cycles even if there is more than one arc contained in both cycles.

\begin{prop}
 Given two cycles $C_1, C_2$ with a set of shared arcs $J:=\{a\in C_1|a\in C_2\}$ which we assume to have size greater 
than one ($j:=|J|>1$). If $J$ is a path in the graph with no sink or source vertex in the interior, the acyclicity of 
$C_1, C_2$ together implies acyclicity of the cycle $C_3:=C_1\cup C_2\setminus C_1\cap C_2$.
\end{prop}
\begin{proof}
 We prove this via contradiction. If the common arcs $J$ are a path like above, they have flow always in the same 
direction. Suppose $C_1$ and $C_2$ are acyclic, but $C_3$ is not. This means in both $C_1$ and $C_2$ there are arcs 
with different directions on the cycle, while they are all in the same direction on $C_3$. This means, the arcs with 
different direction have to be in the path $J$ of shared arcs of $C_1$ and $C_2$. Hence within the path $J$ there must 
be arcs which are directed oppositely to each other. This can only happen, if one of the vertices in the interior of 
$J$ is a sink or a source. \Lightning
\end{proof}
%verallgemeinerung: teilt ein kreis den graph in zwei teile, dann ist es ausreichend wenn im innern azyklizität gegeben 
%und keine quelle/senke vorhanden ist? (verallgemeinerung von planarem Fall)
We can prove something more general by giving conditions that apply in more cases:
\begin{prop}
 Given a graph $G=(V,A)$ , without loss of generality assumed to be connected, and a cycle $C\subset G$ with the 
following properties:
 \begin{itemize}
  \item $G\setminus C$ is disconnected
  \item Let $G'$ be a connected component of $G\setminus C$ 
  \item $G'$ has no source or sink nodes
  \item $G'\cup C$ consists of cycles whose direct sum is $C$ %TODO is direct sum what I really mean? Define it?
 \end{itemize}
 Then any acyclic orientation of the other cycles than $C$ in $G'\cup C$ implies already the acyclicity of $C$. This 
  means the acyclicity constraint of $C$ is redundant.

\end{prop}
%Beweisen, dass in einem Gebiet ohne Quellen oder Senken (das planar ist?) einfache kreise reichen
\begin{proof}
 Consider only the subgraph $G'\cup C$ and assume $C$ had a cyclic orientation. In $C$ there has to be a chordal path 
through $G'$. Since there are no sources or sinks in $G'$, in fact there must be a \textit{directed} path from one node 
$v_1 \in C$ to another node $v_k\in C$ going through $G'$: starting from any arc incident to a node on $C$ and one in 
$G'$, we will always find another arc from the endnode in the same direction unless we run into a cycle or a 
source/sink node. But since neither exists in $G'$, after a finite number of arcs we come to a node on $C$ again. Thus 
we can always find a directed path in our setting. 

But there are two smaller cycles $C_1$ and $C_2$ if we divide $C$ along this path. $C$ is a directed cycle and the path 
is also directed $\Rightarrow$ so one of the two cycles has to be directed, which contradicts our assumption. 
\Lightning 

Hence we conclude that acyclicity and absence of sources/sinks in the interior of a cycle make its acyclicity 
constraint redundant.
\end{proof}

%remark that this more general proposition is important for the planar case
There are some special cases where the above result can be very helpful and indeed reduce the number of needed 
acylicity constraints to polynomial size. This is not only relevant in theory, but also in practice: a real world gas 
network might have (at least partially) a planar graph representation. Planar graphs fulfill the condition to find a 
cycle which is dividing the graph into different parts easily - each cycle in a planar graph embedding divides the 
graph 
into interior and exterior. If we have only one source and one sink and find an embedding where both are on the outer 
(unbounded) face of the graph, it is sufficient to have the acyclicity constraints only on the face cycles of the 
graph. The same holds for all areas or subgraphs without sources/sinks that are enclosed by a cycle: we only need small 
simple cycles and all other acyclicity constraints are redundant.

% TODO BILD : Bei einem Gitter mit vielen Quellen/Senken sind wir verloren... !
Still we have a problem with the sources and sinks. If there are many of them we still run into exponential numbers of 
acyclicity constraints.

\newpage
\subsection{The Constrained Path Augmentation Model}%TODO kann man so ein modell finden, das mithilfe von constrained 
% shortestpath problemen einen successive shortest path algo zu einem maxflowbound-algo macht? duerfte schwer werden...
\label{model:pathaugment}
The main idea in this chapter was to design an algorithm that uses path augmentation to saturate the given flow 
demands. 
The algorithm should try to push as much flow value as possible over the arc where flow is maximized, while having the 
constraint that the resulting flow is acyclic. %TODO geht das ueberhaupt mit succ shortest path?
Algorithms that use path augmentation to compute flows are well known and among the standard flow algorithms. The 
algorithm of Ford and Fulkerson \cite{Ford-Fulkerson_algo} arising from their Max-Flow-Min-Cut theorem is based on 
source-sink-paths in the network as well as the improved algorithms of Edmonds and Karp \cite{EdmondsKarp1972} or Dinic 
\cite{Dinic1970}. 

This idea of path augmentation is conveniant and nice looking in the beginning. It is the base for a direct heuristic 
approach to the problem that can produce valid bounds very fast. We also show the difficulties of choosing a path and 
illustrate with examples that only a relaxed version or either an algorithm with edge progressions instead of simple 
paths can work for the acyclic flowbound problem.\\

If we want to maximize flow over arc $e=(u,v)$ the first idea might be to just search a path from $v$ to the sink $t$ 
and another path from the sink $s$ to $u$. Finding such a path can be done by graph search in the graph of augmentable 
arcs in linear time. Also the combined path of the two would always use the arc $e$.
But it is not sufficient to just combine a path from source $s$ to node 
$u$ and one from node $v$ to a sink $t$. Such a combination could produce cyclic flow, see for example figure 
\ref{bild:cycleFromCombinedPaths}. %TODO BILD

%Bild: combining two paths can produce a cycle TODO noch verbessern... z.b. kreis mit einem loop markieren
\begin{figure}[h!]
\centering
\begin{tikzpicture}
% [scale=2, vertex/.style={circle,fill=black},arrow/.style={-latex, shorten >=0.2ex, shorten <=0.2ex}]
\node (a) at (2,0)[vertex, label=below:$v$]{};
% \node (stext) at (-0.1, 0.2){s};
\node (b) at (1,-0.5)[vertex,label=below:$u$]{} ;
\node (c) at (1,1)[vertex]{};
\node (s) at (1.5,1.5)[vertex, label=s]{};
\node (t) at (0,1)[vertex, label=left:t]{};

\draw[arcflow, magenta] (s)--(c)--(b);
\draw[arcflow, light blue] (a)--(c)--(t);
\draw[arcflow, blue!50!magenta] (b)--(a);
\draw[fatarc] (b) -- (a)node [pos=0.5, above, black] {e};
\draw[edge] (s) to (c);
\draw[edge] (c) to (b);
\draw[edge] (c) to (t);
\draw[edge] (a) to (c);
\draw[ultra thick, ->, red!50] (1.55,0.27) arc (30:330:0.23);
\end{tikzpicture}
\caption{This small network shows that combining two independent paths (blue, magenta) from both endes of the maximized 
arc unto source and sink can lead to cyclic flow}
 \label{bild:cycleFromCombinedPaths}
\end{figure}

The next straightforward idea is to use simple paths containing the arc we want to maximize. This means we would just 
forbid that the two paths we found have 
vertices in common. 
But it is also not sufficient to just use simple paths: it might happen that two different paths intersect in 
such a way that the combination of these paths produces a flow cycle (see figure 
\ref{bild:cycleFromDifferentCombinedPaths}).

\begin{figure}[h!]
\centering
\begin{tikzpicture}
% [scale=2, vertex/.style={circle,fill=black},arrow/.style={-latex, shorten >=0.2ex, shorten <=0.2ex}]
\node (a) at (2,0)[vertex, label=below:$v$]{};
% \node (stext) at (-0.1, 0.2){s};
\node (b) at (1,-0.5)[vertex,label=below:$u$]{} ;
\node (c) at (1,1)[vertex]{};
\node (s1) at (1.5,1.5)[vertex, label=$s_1$]{};
\node (t1) at (2.5,-1)[vertex, label=$t_1$]{};
\node (s2) at (0,-1.5)[vertex, label=left:$s_2$]{};
\node (t2) at (0,1)[vertex, label=left:$t_2$]{};

\draw[arcflow, magenta] (s1)--(c)--(b);
\draw[arcflow, magenta] (a)--(t1);
\draw[arcflow, light blue] (a)--(c)--(t2);
\draw[arcflow, light blue] (s2)--(b);
\draw[arcflow, blue!50!magenta] (b)--(a);
\draw[fatarc] (b) -- (a)node [pos=0.5, above, black] {e};
\draw[edge] (s1) to (c);
\draw[edge] (c) to (b);
\draw[edge] (c) to (t2);
\draw[edge] (a) to (c);
\draw[edge] (s2) to (b);
\draw[edge] (a) to (t1);
\draw[ultra thick, ->, red!50] (1.55,0.27) arc (30:330:0.23);
\end{tikzpicture}
\caption{If we combine two simple $s-t$-paths (blue and magenta) going over $e$ we might get a crossing of both, 
leading to cyclic flow}
 \label{bild:cycleFromDifferentCombinedPaths}
\end{figure}

In order to design an algorithm that uses such path augmentations, it is thus necessary to put acyclicity into the path 
choosing procedure as a constraint. The condition that flow on an arc $e$ is maximized still has to be the objective.
However, if we want to successively search and augment paths in the network it might be necessary to augment flow 
backwards - i.e. to change previously chosen paths due to an acyclicity issue of the current path.
This is a problem for easy path searching methods. If we have to choose a next node for the path locally and do not 
know if we have to change a previous path we might have to branch on the decisions. It is even worse: 

If the algorithm chooses to augment the wrong path it can happen that \textit{no} simple $s-t$-path can be augmented -
although there exists an acyclic flow with a higher flow value $f(e)$. Figure \ref{bild:blockingPathflowNet} shows such 
a situation where path augmentation is useless because in the first step a wrong path was chosen. 

\begin{figure}[h!]
\centering
\begin{tikzpicture}
%picture to show how bad path flow augmentation can block arcs such that no simple path can obtain optimality anymore
\node (a) at (0,3)[vertex]{};
\node (s1) at (1,2.5)[source]{-1};
\node (b) at (2,3)[vertex]{};
\node (d) at (2,2)[vertex]{};
\node (c) at (1.5,0)[vertex]{};
\node (s2) at (3,3)[source]{-1};
\node (t) at (1.5,1)[sink]{2};
% \draw[arcflow] (s)--(3)--(t);
\draw[fatarc] (b)--(a)node[pos=0.5, above]{$e$};
% \draw[edge] (a)--(s1)--(d)--(b)--(s2)--(c)--(a);
% \draw[edge] (c)--(t)--(d);
\draw[edge] (a)--(s1)node [pos=0.5, above] {2};
\draw[edge] (s1)--(d)node [pos=0.5, above] {1};
\draw[edge] (d)--(b)node [pos=0.5, right] {2};
\draw[edge] (b)--(s2)node [pos=0.5, above] {2};
\draw[edge] (s2)--(c)node [pos=0.5, above] {2};
\draw[edge] (c)--(a)node [pos=0.5, above] {2};
% \draw[edge] (a)--()node [pos=0.5, above, blue] {2};
\draw[edge] (c)--(t)node [pos=0.5,right] {2};
\draw[edge] (t)--(d)node [pos=0.5, above] {2};
\end{tikzpicture}
\caption{Example graph with capacities on all arcs and demand values at sources and sinks}
 \label{bild:blockingPathflowNet}
\end{figure}

\begin{figure}[h!]
\centering
\begin{tikzpicture}
%picture to show how bad path flow augmentation can block arcs such that no simple path can obtain optimality anymore
\node (a) at (0,3)[vertex]{};
\node (s1) at (1,2.5)[source]{-1};
\node (b) at (2,3)[vertex]{};
\node (d) at (2,2)[vertex]{};
\node (c) at (1.5,0)[vertex]{};
\node (s2) at (3,3)[source]{-1};
\node (t) at (1.5,1)[sink]{2};
\draw[arcflow, cyan, dashed] (s1)--(d)--(b);
\draw[arcflow, cyan](b)--(a)--(c)--(t);
\draw[arcflow, yellow, dashed] (s2)--(b)--(a)--(c)--(t);
\draw[fatarc] (b)--(a)node[pos=0.5, above]{$e$};
\draw[edge] (a)--(s1){};
\draw[edge] (s1)--(d){};
\draw[edge] (d)--(b){};
\draw[edge] (b)--(s2){};
\draw[edge] (s2)--(c){};
\draw[edge] (c)--(a){};
\draw[edge] (c)--(t){};
\draw[edge] (t)--(d){};
\end{tikzpicture}
\caption{The optimum - the whole amount of flow is going over $e$ while the flow is still acyclic in the whole network}
 \label{bild:blockingPathflowOpt}
\end{figure}

\begin{figure}[h!]
\centering
\begin{tikzpicture}
[scale=0.7]
%picture to show how bad path flow augmentation can block arcs such that no simple path can obtain optimality anymore
\node (a) at (0,3)[vertex]{};
\node (s1) at (1,2.5)[source]{-1};
\node (b) at (2,3)[vertex]{};
\node (d) at (2,2)[vertex]{};
\node (c) at (1.5,0)[vertex]{};
\node (s2) at (3,3)[source]{-1};
\node (t) at (1.5,1)[sink]{2};
\draw[arcflow, cyan] (s2)--(b)--(a);
\draw[arcflow, cyan](a)--(s1)--(d)--(t);
% \draw[arcflow, yellow, dashed] (s1)--(a)--(c)--(t);
\draw[fatarc] (b)--(a)node[pos=0.5, above]{$e$};
\draw[edge] (a)--(s1)node [pos=0.5, above] {2};
\draw[edge] (s1)--(d)node [pos=0.5, above] {1};
\draw[edge] (d)--(b)node [pos=0.5, right] {2};
\draw[edge] (b)--(s2)node [pos=0.5, above] {2};
\draw[edge] (s2)--(c)node [pos=0.5, above] {2};
\draw[edge] (c)--(a)node [pos=0.5, above] {2};
\draw[edge] (c)--(t)node [pos=0.5,right] {2};
\draw[edge] (t)--(d)node [pos=0.5, above] {2};
% \draw[edge] (a)--(s1){};
% \draw[edge] (s1)--(d){};
% \draw[edge] (d)--(b){};
% \draw[edge] (b)--(s2){};
% \draw[edge] (s2)--(c){};
% \draw[edge] (c)--(a){};
% \draw[edge] (c)--(t){};
% \draw[edge] (t)--(d){};
\node (2a) at (4,3)[vertex]{};
\node (2s1) at (5,2.5)[source]{-1};
\node (2b) at (6,3)[vertex]{};
\node (2d) at (6,2)[vertex]{};
\node (2c) at (5.5,0)[vertex]{};
\node (2s2) at (7,3)[source]{-1};
\node (2t) at (5.5,1)[sink]{2};
\draw[arcflow, cyan] (2s2)--(2b)--(2a);
\draw[arcflow, cyan](2a)--(2s1)--(2d)--(2t);
\draw[arcflow, yellow, dashed] (2s1)--(2a)--(2c)--(2t);
\draw[fatarc] (2b)--(2a)node[pos=0.5, above]{$e$};
\draw[edge] (2a)--(2s1)node [pos=0.5, above] {2};
\draw[edge] (2s1)--(2d)node [pos=0.5, above] {1};
\draw[edge] (2d)--(2b)node [pos=0.5, right] {2};
\draw[edge] (2b)--(2s2)node [pos=0.5, above] {2};
\draw[edge] (2s2)--(2c)node [pos=0.5, above] {2};
\draw[edge] (2c)--(2a)node [pos=0.5, above] {2};
\draw[edge] (2c)--(2t)node [pos=0.5,right] {2};
\draw[edge] (2t)--(2d)node [pos=0.5, above] {2};
\end{tikzpicture}
\caption{With the given capacities and the already augmented blue flow (left picture) there exists no simple path from 
the middle source to the sink such that 
flow on $e$ could be increased. The best possibility is to augment the dashed yellow path which yields a flow 
value $f(e)=1$ on the maximized arc. This is not optimal as figure \ref{bild:blockingPathflowOpt} showed}
 \label{bild:blockingPathflow}
\end{figure}

This example clearly shows the problems of a path based augmentation approach. A flow could block the wrong arcs while 
the next augmentation step possibly needs these arcs. 
We must give up the idea of finding simple paths and relax them to edge progressions. An edge progression can 
contain arcs and vertices more than once. Thus it can do some kind of cyclic shifting on the flow. Since two flows with 
the same balances in the same network only differ by cyclic flow we can change the flow network to the state we desire. 
Whenever needed the optimal edge progression can do a cyclic shift and afterwards augment the actual path. \\

Here we will not try to deal with the problem of finding such an edge progression. It is likely to be as 
difficult as the acyclic flowbound problem itself. Nevertheless  we describe the algorithm 
in pseudocode (\ref{algo:pathHeur}) to show how such an algorithm would look like if we 
could find such paths or edge progressions and to use it as basis for a heuristic approach.

% 
% Instead we assume we had a blackbox algorithm giving us 
% a path to augment - if necessary augmenting flow back (and by this changing other paths from former iterations) - such 
% that the result is an acyclic flow and uses a specified arc if required. We show how such an algorithm could be used to 
% compute an upper bound for the flow on the specified arc of a network.\\
% 
% %algo um mit dieser blackbox die optimale flussschranke zu berechnen!
% 
% We will specify the heuristic algorithm here in pseudocode and show that it yields a valid bound not higher than the 
% sum of flow from all sources. %We will also analyze its worst-case running time.TODO?

%Pseudocode des Algorithmus
\begin{algorithm}
 \caption{path based heuristic flow bound algorithm}
\label{algo:pathHeur}
 %TODO gehe gerade von vorwärts gerichteter e aus, und maximierung
 \begin{algorithmic}[5]%[0] means no line numbers, n means every nth line number is displayed
  \Function{Heuristic}{$G=(V,A),\, e=(u,v)\in A,\, b:V\to \R $}%hier übergabeparameter
    \State define $b':V\to \R,\, b'(v)\gets 0 \forall v\in V$ \Comment{temporary balances}
    \State define $f: A\to\R,\, f(v)\gets 0 \forall a\in A$
    \While {$\neg (b+b'\equiv 0) $}\Comment{while there are active source-sink-pairs}
      \If{ $c(e)>f(e)$}
      \State choose active source $v\in V$ 
	\State $P\gets $\Call{acyclicEdgeProgOverE}{$v, e$}
	  %\Comment{find augmentable path over $e$ such that we still have acyclic flow after augmentation}
	\If{$P\ne \emptyset $}
	  \State \Call {maxAugment}{$P$}\label{heur:lineAugCase1}
	  \State \textbf{continue}
	\EndIf
      \EndIf
%       \Else
	\State choose $s\in V$ with $b(s)+b'(s)<0$\Comment{source that is still active}
	\State $c_{alt}(e)\gets c(e)$\Comment{save old capacity value}
	\State $c(e)\gets f(e)$\Comment{make $e$ blocked for a short time}
	\State $P\gets$\Call{acyclicEdgeProg}{$s$}\Comment{try finding a path that avoids $e$}
	\State $c(e)\gets c_{alt}(e)$
	\If{$P\ne \emptyset$}
	  \State \Call {maxAugment}{$P$}\label{heur:lineAugCase2}
	  \State \textbf{continue}
	\Else
	  \State $P\gets$ \Call{acyclicEdgeProg}{$s$}
		\Comment{try to find any augmentable path, at this point of time it will be decreasing the flow on $e$}
	  \If{$P\ne \emptyset$}
	    \State \Call {maxAugment}{$P$}\label{heur:lineAugCase3}
	    \State \textbf{continue}
	  \Else
	    \State \Return problem infeasible
	  \EndIf
	\EndIf
    \EndWhile
    \State \Return $f(e)$
  \EndFunction
%   \algstore{heur}
 \end{algorithmic}

\end{algorithm}

%algo um maximum zu augmentieren
\begin{algorithm}
 \begin{algorithmic}
  \Function {maxAugment}{$P$}
    \State $s \gets $ source node of $P$
    \State $t \gets $ sink node of $P$
    \State augval $\gets \min(|s|,|t|)$
    \ForAll{$a\in P$}
      \State arcMaxAugval $\gets$ max augmentable flow in direction of $P$ on $a$ 
      \State augval $\gets \min($augval, arcMaxAugval)
    \EndFor
    \ForAll{$a\in P$}
%       \If{$a$ is considered the second time in the same direction in $P$}
% 	\State \textbf{continue}\Comment do not increase flow value here, equivalent to increase of capacity bounds on 
% 		this arc. Why this is necessary see example \ref{example:mustNotAugmentArcTwice}
%       \EndIf
      \State increase flow on $a$ in direction of $P$ by augval
    \EndFor
    \State $b'(s) \gets b'(s) + $augval
    \State $b'(t) \gets b'(t) - $augval
  \EndFunction
 \end{algorithmic}
\end{algorithm}

\begin{prop}
 The described algorithm \ref{algo:pathHeur} together with a function \textit{acyclicEdgeProg()} 
 resp. \textit{acyclicEdgeProgOverE} 
 that finds an augmentable edge progression (acyclicEdgeProgOverE using a specified arc $e$)
 whose augmentation is not causing any flow cycles computes the optimal bounds to the acyclic flowbound problem. 
\end{prop}
\begin{proof}
 We assume that the blackbox algorithm for finding an acyclic edge progression is correct. An edge progression can use
 arcs more than once $\Rightarrow$ it can do cyclic shifting on every cycle in the same connected component: 
 For every cyclic shift that is necessary it chooses an augmentable path towards the cycle, then goes around the cycle 
 and on the same way back. If there is no augmentable path unto a cycle in the same connected component there has to be
 a directed cut that is at its capacity bounds. But in this case this cycle (and everything behind the cut) cannot 
 influence the acyclic path at all.
 If the algorithm can change the flow on every cycle, it can produce every acyclic flow that is possible (before augmenting).
 There is always a path if there is any acyclic flow with this flow value on $e$ because every acyclic flow can be 
 decomposed into flow on simple paths. So the optimal edge progression could detect the right $s-t$-path, produce the 
 acyclic flow without this path and then augment. So if the algorithm does not find any edge progression, there 
 is also no acyclic flow with a higher flow value on $e$.  
\end{proof}

So we have seen that augmentation algorithms could only work with a too powerful algorithm that shifts flow before 
augmenting on a path. The main problem is that a flow can unnecessarily block an arc that is needed in a later stage 
of the algorithm. 

So the following idea for a heuristic algorithm comes in: Can we increase the capacity bounds of the arcs in a way 
such that they can only be blocked in the case when the acyclic flow bound is reached?\\

Yes: if we double the capacities there will be no more flows blocked if not necessary: Even in flows that do not 
require acyclicity an upper bound for flow on an arc $e$ is the flow that can be sent from sources to one end of the 
maximized arc $e$ as well as the flow that can be sent from the other end of $e$ to sinks. This flow can be computed by 
the standard maximum flow algorithms where path augmentation works well. But on each part of the problem - maximum flow 
from sources to one end of $e$ and maximum flow from the other end vertex of $e$ to sinks - the capacity of each arc in 
the network can only be used one time. So combining these two would give twice the capacity at most. Thus we can 
conclude that a more restricted problem (like finding the acyclic bound) can not need more capacity than this on a 
single arc.\\

We will describe an equivalent variant of this idea in the next section more detailed.
 

\input{heuristic}
